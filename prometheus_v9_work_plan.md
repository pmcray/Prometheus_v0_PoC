
# Project Prometheus v0.9 Work Plan: The Dynamic Mesh

**Generated by Gemini**

---

## Abstract

This document outlines the detailed work plan for the next major phase of the Project Prometheus demonstrator, v0.9. This phase, titled "The Dynamic Mesh," is designed to be the most impressive and conceptually significant version of the PoC. It directly tackles the advanced, and often abstract, ideas from Good's paper—specifically the dynamic formation of expert circuits (Subassembly) and the ability to handle multiple, competing hypotheses at once (Ultraparallelism). It also explicitly incorporates GPU acceleration and a unified codebase that can be seamlessly demonstrated in a Colab notebook.

---

## Task 1: GPU Acceleration and Unified Colab Demonstrator

### Rationale

To handle the increased computational load of parallel simulations and to create a compelling, easily shareable demonstration, the system must be optimized for GPU execution and consolidated into a single, polished Jupyter Notebook for Colab.

### Methodology

1.  **Containerize with GPU Support:** The `Dockerfile` will be upgraded to use a base image that includes CUDA and the necessary NVIDIA container toolkit dependencies. This will ensure that the system can leverage the GPU on the Jetson Orin Nano.
2.  **Refactor for Colab:** All the individual Python scripts (`planner.py`, `coder.py`, etc.) will be consolidated into a single, well-documented Jupyter Notebook (`Prometheus_v0.9.ipynb`). The notebook will be structured with clear Markdown explanations for each step, making it a self-contained, executable demonstration.
3.  **GPU-Accelerated LLM Calls:** The `CoderAgent` and `PlannerAgent` will be modified to ensure that all calls to the Gemini API are configured to run on the GPU, which will be automatically detected in the Colab environment.

### Deliverables

-   An updated `Dockerfile` with GPU support for the Jetson Orin Nano.
-   A single, polished `Prometheus_v0.9.ipynb` notebook that contains the entire, executable PoC.
-   Agents configured to utilize GPU acceleration for all LLM interactions.

### Verification

The system can be successfully built and run as a Docker container on the Jetson Orin Nano, with logs showing GPU utilization. The `Prometheus_v0.9.ipynb` notebook can be run from top to bottom in a Google Colab environment (with a GPU runtime) without errors, successfully demonstrating all subsequent tasks.

---

## Task 2: Implement Ultraparallelism - Multi-Hypothesis Experimentation

### Rationale

A truly intelligent system, as envisioned by Good, should be able to entertain and test multiple, competing hypotheses in parallel. This "Ultraparallelism" is a key to rapid discovery and avoiding cognitive "dead ends."

### Methodology

1.  **Upgrade `PlannerAgent` - Hypothesis Generation:** The `PlannerAgent` will be upgraded. Instead of generating a single hypothesis, it will now be tasked with generating a *set* of diverse, competing hypotheses to explain a phenomenon in the `ToyChemistrySim`.
2.  **Upgrade `MCSSupervisor` - Parallel Experimentation:** The `run_experimental_cycle` will be refactored to be a `run_parallel_experiments` method. It will take the list of hypotheses, and for each one, it will:
    -   Create a separate, sandboxed instance of the `ToyChemistrySim`.
    -   Task the `CoderAgent` with translating the hypothesis into an experiment.
    -   Run all experiments in parallel (leveraging Python's `multiprocessing` or `asyncio` to simulate this).
3.  **Upgrade `EvaluatorAgent` - Comparative Analysis:** The `EvaluatorAgent` will be given a new role. It will receive the results from all parallel experiments and will be tasked with performing a comparative analysis to determine which hypothesis was most successful.

### Deliverables

-   A `PlannerAgent` capable of generating a diverse set of competing hypotheses.
-   An `MCSSupervisor` that can manage multiple, parallel, sandboxed simulations.
-   An `EvaluatorAgent` that can perform a comparative analysis of experimental results.

### Verification

When tasked with the `ToyChemistrySim` challenge, the `PlannerAgent` must generate at least three distinct hypotheses (e.g., "Mix A and B," "Heat A," "Mix B and C"). The `MCSSupervisor` must then execute all three experiments in parallel, and the `EvaluatorAgent` must correctly identify "Mix A and B" as the most promising initial result.

---

## Task 3: Implement Dynamic Subassembly - The Expert Circuit

### Rationale

This is the core of the v0.9 PoC and a direct implementation of Good's "Subassembly" concept. Instead of a static, pre-defined team of agents, the system will now be able to dynamically assemble and dissolve "expert circuits"—temporary, specialized teams of agents—to solve a specific sub-problem.

### Methodology

1.  **Create Agent "Templates":** A set of "template" agent classes will be created (e.g., `HypothesisGenerator`, `DataAnalyzer`, `CodeImplementer`). These are not active agents but blueprints.
2.  **Upgrade `PlannerAgent` - Circuit Formation:** The `PlannerAgent` will be significantly upgraded. When faced with a complex problem, it will first analyze the problem and then define a *custom team* of agents required to solve it. It will do this by selecting from the available templates and giving each a specific, narrow role.
3.  **Upgrade `MCSSupervisor` - Dynamic Instantiation:** The `MCSSupervisor` will be upgraded. It will receive the "circuit" definition from the `PlannerAgent` and will be responsible for dynamically instantiating the required agents and orchestrating their interaction for the duration of the task. Once the task is complete, the supervisor will dissolve the circuit.

### Deliverables

-   A set of agent "templates" that can be dynamically instantiated.
-   A `PlannerAgent` that can analyze a problem and define a custom "expert circuit" to solve it.
-   An `MCSSupervisor` that can dynamically form, manage, and dissolve these circuits.

### Verification

When given a new, multi-faceted task (e.g., "Analyze this scientific paper and then try to replicate its findings in the `ToyChemistrySim`"), the `PlannerAgent` must correctly identify the need for a two-stage circuit. The logs must clearly show the supervisor first instantiating a "Literature Review" circuit and then, after that is complete, dissolving it and instantiating a new "Scientific Experiment" circuit.
